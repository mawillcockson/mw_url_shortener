# mypy: allow_any_expr
from typing import TYPE_CHECKING, List, Optional

from sqlalchemy import select
from sqlalchemy.exc import IntegrityError

from mw_url_shortener.database.models.log import RedirectModel
from mw_url_shortener.database.start import AsyncSession, sessionmaker
from mw_url_shortener.schemas.log import Log, LogCreate
from mw_url_shortener.settings import defaults

from .base import DBInterfaceBase

if TYPE_CHECKING:
    from typing import Union

    from fastapi import Request, Response
    from fastapi.exceptions import RequestValidationError
    from starlette.exceptions import HTTPException


class LogDBInterface(
    DBInterfaceBase[Log, LogCreate, LogUpdate],
):
    async def create_from_api_success(
        self,
        /,
        *,
        request: "Request",
        response: "Response",
    ) -> None:
        "create a log entry from the data in an API response"
        raise NotImplementedError

    async def create_from_api_exception(
        self,
        /,
        *,
        request: "Request",
        exception: "Union[RequestValidationError,HTTPException]",
    ) -> None:
        "create a log entry from an exception generated by the API"
        raise NotImplementedError

    async def create(
        self,
        opened_resource: AsyncSession,
        /,
        *,
        create_object_schema: LogCreate,
    ) -> Optional[Log]:
        event = create_object_schema.event
        event_json = event.json()
        log_model = LogModel(date_time=create_object_schema.date_time, event=event_json)
        try:
            async with opened_resource.begin():
                opened_resource.add(log_model)
        except IntegrityError as err:
            print(f"error '{err}' encountered while trying to log:\n{event}")
            return None
        await opened_resource.refresh(log_model)
        await opened_resource.close()  # .refresh() opens a new session
        return Log.from_orm(log_model)

    async def search(
        self,
        opened_resource: AsyncSession,
        /,
        *,
        skip: int = 0,
        limit: int = 100,
        id: Optional[int] = None,
    ) -> List[Log]:
        log_schemas: List[Log] = []
        query = select(LogModel)
        if id is not None:
            query = query.where(LogModel.id == id)

        query = query.offset(skip).limit(limit).order_by(LogModel.id)
        async with opened_resource.begin():
            log_models = (await opened_resource.scalars(query)).all()
            for log_model in log_models:
                log_schemas.append(self.schema.from_orm(log_model))
        return log_schemas

    async def update(
        self,
        opened_resource: AsyncSession,
        /,
        *,
        current_object_schema: Log,
        update_object_schema: LogUpdate,
    ) -> Optional[Log]:
        """
        I do not want to be able to modify log entries
        """
        raise NotImplementedError(self.update.__doc__)

    async def remove_by_id(
        self, opened_resource: AsyncSession, /, *, id: int
    ) -> Optional[Log]:
        """
        I do not want to be able to delete log entries
        """
        raise NotImplementedError(self.remove_by_id.__doc__)


log = LogDBInterface(LogModel, Log)
